<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" selectorator Modules selectorator Source: index.js // external dependencies import {identity} from 'identitate'; // utils import { getSelectorCreator, getStandardSelector, getStructuredSelector, isPlainObject, throwInvalidPathsError, throwNoPathsError } from './utils'; /** * @module selectorator */ /** * @function createSelector * * @description * create a selector without any boilerplate code * * @example * import createSelector from 'selectorator'; * * const getFilteredItems = createSelector(['items', 'filter.value'], (items, filterValue) =&gt; { * return items.filter((item) =&gt; { * return item.indexOf(filterValue) !== -1; * }); * }); * * const state = { * items: ['foo', 'bar', 'foo-bar'], * filter: { * value: 'foo' * } * }; * * console.log(getFilteredItems(state)); // ['foo', 'foo-bar']; * console.log(getFilteredItems(state)); // ['foo', 'foo-bar'], pulled from cache; * * @param {Array&lt;function|string&gt;|Object} paths paths to retrieve from state as parameters in getComputedValue, or * an object of key =&gt; path pairs that will assign path at state to key in structured selector * @param {function} [getComputedValue=identity] function that will accept the values at paths in state as parameters * and compute the next result * @param {Object} [options={}] additional options available for selector creation * @param {boolean} [options.deepEqual=false] should strict equality be used for memoization * @param {function} [options.memoizer=defaultMemoize] custom memoize function for creating selectors with * @param {Array&lt;*&gt;} [options.memoizerParams=[]] additional parameters to pass to the selectorCreator function * @returns {function} selector for state object passed */ const createSelector = (paths, getComputedValue = identity, options = {}) =&gt; { const selectorCreator = getSelectorCreator(options); if (isPlainObject(paths)) { return getStructuredSelector(paths, selectorCreator); } if (!Array.isArray(paths)) { throwInvalidPathsError(); } if (!paths.length) { throwNoPathsError(); } return getStandardSelector(paths, selectorCreator, getComputedValue); }; export default createSelector; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" selectorator Modules selectorator Modules × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" selectorator Modules selectorator selectorator 1.3.0 selectorator selectorator is an abstraction API for creating selectors via reselect with less boilerplate code. Table of contents Installation Versions Usage Advanced usage Development Installation $ npm i selectorator --saveVersions Versions of selectorator on the 3.x.x versions will use the 3.x.x version of reselect as a dependency, and all major versions of selectorator will match the major versions of reselect going forward. If you wish to still use the 2.x.x branch of reselect for your application, then you should continue using the 1.x.x branch of selectorator. All future enhancements will be made to both branches, unless they are version-specific. If you would like to learn more about the breaking changes related to the major version change for reselect, please visit the reselect CHANGELOG. Usage import createSelector from 'selectorator'; // selector created with single method call const getBarBaz = createSelector(['foo.bar', 'baz'], (bar, baz) =&gt; { return `${bar} ${baz}`; }); const state = { foo: { bar: 'bar' }, baz: 'baz' }; console.log(getBarBaz(state)); // &quot;bar baz&quot;Not a whole lot of magic here, just simplifying the creation of the &quot;identity selectors&quot; that reselect requires, instead replacing them with a standardized dot- or bracket-notation string for retrieval of a nested property in the state object. That said, you can still use your own custom identity selectors, or compose selectors, if you so choose. Here is the example from the reselect README modified to use selectorator: // subtotal built using simple method const getSubtotal = createSelector(['shop.items'], (items) =&gt; { return items.reduce((sum, {value}) =&gt; { return sum + value; }, 0); }); // tax build with simple method combined with other selector const getTax = createSelector([getSubtotal, 'shop.taxPercent'], (subtotal, taxPercent) =&gt; { return subtotal * (taxPercent / 100); }); // total build entirely with other selectors const getTotal = createSelector([getSubtotal, getTax], (subtotal, tax) =&gt; { return { total: subtotal + tax }; }); const state = { shop: { taxPercent: 8, items: [ {name: 'apple', value: 1.20}, {name: 'orange', value: 0.95} ] } }; console.log('subtotal: ', getSubtotal(state)); // 2.15 console.log('tax: ', getTax(state)); // 0.172 console.log('total: ', getTotal(state)); // {total: 2.322}Advanced usage All the capabilities that exist with reselect are still available using selectorator, they are just passed as an object of options to createSelector. deepEqual defaults to false A common usage of custom selectors is to perform a deep equality check instead of the standard strict equality check when comparing values. To apply this, simply set deepEqual to true. import createSelector from 'selectorator'; const selectoratorOptions = { deepEqual: true }; const getBaz = createSelector(['foo.bar.baz'], (baz) =&gt; { return !!baz; }, selectoratorOptions);isEqual defaults to isSameValueZero If you want to use a custom equality comparator, pass the method as this option. import createSelector from 'selectorator'; const selectoratorOptions = { // silly example checking current or next values related to &quot;foo&quot; isEqual(currentFoo, nextFoo) { return currentFoo === 'foo' || nextFoo !== 'foo'; } }; const getFoo = createSelector(['foo'], (foo) =&gt; { return !!foo; }, selectoratorOptions);Please note that if this parameter is provided and deepEqual is also set to true, deepEqual will take priority and the isEqual method will not be used. memoizer defaults to reselect defaultMemoize If you want to use a custom memoizer, pass the method as this option. This will use createSelectorCreator from reselect internally, so consult their documentation on proper usage. import createSelector from 'selectorator'; import moize from 'moize'; const selectoratorOptions = { memoizer: moize }; const getFoo = createSelector(['foo'], (foo) =&gt; { return !!foo; }, selectoratorOptions);memoizerParams defaults to [] reselect allows you to pass parameters to the memoizer function, and this array will translate directly into parameters 3-n. This is useful if your memoizer uses something other than direct comparison for its equality test. import createSelector from 'selectorator'; const selectoratorOptions = { memoizer: memoizerThatChecksEqualToEachOtherOrToSpecificValuePassed, memoizerParams: ['specificValue'] }; const getFoo = createSelector(['foo'], (foo) =&gt; { return !!foo; }, selectoratorOptions);Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs prepublish:compile prepublish:compile =&gt; run lint, test:coverage, transpile, build, build:minified, and docs test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-selectorator.html":{"id":"module-selectorator.html","title":"Module: selectorator","body":" selectorator Modules selectorator Module: selectorator Source: index.js, line 9 Methods &lt;inner&gt; createSelector(paths [, getComputedValue] [, options]) create a selector without any boilerplate code Parameters: Name Type Argument Default Description paths Array.&lt;(function()|string)&gt; | Object paths to retrieve from state as parameters in getComputedValue, or an object of key =&gt; path pairs that will assign path at state to key in structured selector getComputedValue function &lt;optional&gt; identity function that will accept the values at paths in state as parameters and compute the next result options Object &lt;optional&gt; {} additional options available for selector creation Properties Name Type Argument Default Description deepEqual boolean &lt;optional&gt; false should strict equality be used for memoization memoizer function &lt;optional&gt; defaultMemoize custom memoize function for creating selectors with memoizerParams Array.&lt;*&gt; &lt;optional&gt; [] additional parameters to pass to the selectorCreator function Source: index.js, line 13 Returns: selector for state object passed Type function Example import createSelector from 'selectorator'; const getFilteredItems = createSelector(['items', 'filter.value'], (items, filterValue) =&gt; { return items.filter((item) =&gt; { return item.indexOf(filterValue) !== -1; }); }); const state = { items: ['foo', 'bar', 'foo-bar'], filter: { value: 'foo' } }; console.log(getFilteredItems(state)); // ['foo', 'foo-bar']; console.log(getFilteredItems(state)); // ['foo', 'foo-bar'], pulled from cache; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
